% concrete-syntax.tex

%!TEX root = main.tex


%===============================================================================
\chapter{The SMT-LIB Language} \label{chap:concrete-syntax}
%===============================================================================
\thispagestyle{empty}

This chapter defines and explains the concrete syntax of the SMT-LIB standard, 
what we comprehensively refer to as \define{the SMT-LIB language}.
The SMT-LIB language has three main components:
\emph{theory declarations}, \emph{logic declarations}, and \emph{scripts}. 
%
Its syntax is similar to that of the LISP programming language.
In fact, every expression in this version is 
a legal \emph{S-expression} of Common Lisp~\cite{Ste-90}. 
The choice of the S-expression syntax and 
the design of the concrete syntax was mostly driven by the goal of simplifying parsing,
as opposed to facilitating human readability.\endnote{
\label{why-LISP-syntax}
Preferring ease of parsing over
%cb human-readability
human readability is reasonable in this context
not only because SMT-LIB benchmarks are meant to be read by solvers
but also because they are produced in the first place by automated tools 
like verification condition generators or translators from other formats.
}

The three main components of the language are defined in this chapter 
by means of BNF-style production rules.
The rules, with additional details, are also provided in Appendix~\ref{app:concrete-syntax}.
The language generated by these rules is actually a superset
of the SMT-LIB language.
The legal expressions of the language must satisfy additional constraints,
such as well-sortedness,
also specified in this document.



%-------------------------------------------------------------------------------
\section{Lexicon}
%-------------------------------------------------------------------------------

The syntax rules in this chapter are given directly with respect to streams
of lexical tokens from the set defined in this section.
The whole set of concrete syntax rules is also available 
for easy reference in Appendix~\ref{app:concrete-syntax}.

%The permitted characters of SMT-LIB source files are a subset of the ASCII character set.
%They consist of all letters, digits, whitespace characters
%(space, tab and line-breaking characters), as well as
%the characters
%\begin{center}
%\verb'~ ! @ # $ % ^ & * _ - + = | \ : ; " < > . ? / ( )'
%\end{center}
%
SMT-LIB source files consist of Unicode characters in any 8-bit encoding, 
such as \href{http://en.wikipedia.org/wiki/UTF-8}{UTF-8},  
that extends the original 7-bit US-ASCII set.
While not technically Unicode,
the \href{http://en.wikipedia.org/wiki/ISO_8859-1}{ISO 8859-1} 
character set is also allowed since it coincides 
with the first 256 characters of UTF-8.\endnote{
The move to the Unicode character standard was motivated by the fact that
US-ASCII is is inadequate in international settings and
Unicode has become the dominant standard. 
}

%\endnote{
%There was much internal discussion on whether to adopt the Unicode UTF-8 standard instead, 
%which is used in most web-based applications currently.
%We opted for ISO 8859-1 mostly because it is a fixed character encoding and is still
%well supported by all operating systems.
%A move to UTF-8 might be made in a later version, depending on the feedback and needs
%of the community.
%}
Most lexical tokens defined below are limited to \href{http://en.wikipedia.org/wiki/ASCII#ASCII_printable_characters}{US-ASCII printable characters},
namely, characters \dec{32} to \dec{126}.
The remaining printable characters,
mostly used for non-English alphabet letters
(characters \dec{128} and beyond), % PF We already specified unicode, no need to say anything about encodings 
are allowed in string literals, quoted symbols, and comments.

%
A \define{comment} is any character sequence 
not contained within a string literal or a quoted symbol (see later)
that begins with the semi-colon character \ter{;}
and ends with the first subsequent line-breaking character,
i.e., \dec{10} or \dec{13}.
Both comments and consecutive white space characters occurring outside
a string literal or a symbol (see later) are considered \define{whitespace}.
The only lexical function of whitespace is to break the source text into tokens.\footnote{%
Which implies that the language's semantics does not depend on indentation and spacing.
}

The lexical tokens of the language are
the parenthesis characters \ter{(} and \ter{)},
the elements of the syntactic categories 
\nter{numeral},
\nter{decimal},
\nter{hexadecimal},
\nter{binary},
\nter{string},
\nter{symbol},
\nter{keyword},
as well as a number of \define{reserved words},
all defined below together with a few auxiliary syntactic categories.


\begin{description}
\item[White Space Characters.]
A \nter{white\_space\_char} is one of the following characters:
\dec{9} (tab), 
\dec{10} (line feed),
\dec{13} (carriage return), and
\dec{32} (space).
%, and \dec{160} (non-breaking space).

\item[Printable Characters.]
A \nter{printable\_char} is any character from 
\dec{32} to \dec{126} (US-ASCII) and from \dec{128} on.\footnote{%
%Note that the space and the non-breaking space characters are both printable and 
%whitespace characters.
Note that the space character is both a printable and a whitespace character.
}

\item[Digits.]
A \nter{digit} is any character from \dec{48} to \dec{57} 
(\ter{0} through \ter{9})

\item[Letters.]
A \nter{letter} is any character 
from \dec{65} to \dec{90} (English alphabet letters \ter{A} through \ter{Z}) and
from \dec{97} to \dec{122} (English alphabet letters \ter{a} through \ter{z}).\endnote{
This syntactical category excludes the non-English letters of Unicode
because it is used to define identifiers, which traditionally use only English letters.
Future versions might extend it to non-English letters as well.
}

\item[Numerals.]
A \nter{numeral} is the digit \ter{0} or a non-empty sequence of digits not starting with \ter{0} .

\item[Decimals.]
A \nter{decimal} is
a token of the form \nter{numeral}\!\!\ter{.0}\!\!$^*$\nter{numeral} .

\item[Hexadecimals.]
A \nter{hexadecimal} is a non-empty \emph{case-insensitive} sequence of digits and letters from \ter{A} to \ter{F} 
preceded by the (case sensitive) characters \ter{\#x} .
\smallskip

\begin{lstlisting}[linewidth=11.6em]
#x0      #xA04  
#x01Ab   #x61ff
\end{lstlisting}

\item[Binaries.]
A \nter{binary} is a non-empty sequence of the characters \ter{0} and \ter{1}
preceded by the characters \ter{\#b} .

\begin{lstlisting}[linewidth=12.5em]
#b0     #b1
#b001   #b101011
\end{lstlisting}

\item[String literals.]
%
% Version 2.0 text
%
%A \nter{string} is any sequence of printable ASCII characters delimited by double quotes 
%(\ter{"})
%and possibly containing the C-style escape sequences \verb+\"+ and \verb+\\+ , 
%both of which are treated as a single character---respectively \verb+"+ and \verb+\+ .
%The first escape sequence allows as usual the double quote character 
%to appear within a string literal,
%the second allows the backslash character to end a string literal.
%
%\begin{lstlisting}[linewidth=33em]
%""    "this is a string literal"    "one\n two"
%"She said: \"Hello!\""    "Here is a backslash: \\" 
%\end{lstlisting}
%
%Note that, \verb+\"+ and \verb+\\+ are the only escape sequences in SMT-LIB.
%So, for example---and in contrast to most programming languages---
%within a \nter{string} the character sequences
%\verb+\n+, \verb+\012+, \verb+\x0A+, and \verb+\u0008+
%are not escape sequences all denoting the same character (new line),
%but regular sequences denoting their individual characters.\endnote{
%This is to achieve maximum generality and independence 
%from programming language conventions.
%Future SMT-LIB theories of strings that use string literals
%as constant symbols will have the liberty to define certain string constants,
%such as \texttt{"$\backslash$n"} and \texttt{"$\backslash$012"},
%as equivalent (or not).
%}
A \nter{string} (literal) is any sequence of characters 
from \nter{printable\_char} or \\
\nter{white\_space\_char}
delimited by the double quote character \ter{"} (\dec{34}).
The character \ter{"} can itself occur \emph{within} a string literal only if
%surrounded by single quotes (\dec{39}) in the sequence \ter{'"'} which is treated as just \ter{"}.
duplicated.
In other words, after an initial \ter{"} that starts a literal, a lexer should
treat the sequence \ter{""} as an escape sequence denoting a single occurrence 
of \ter{"} within the literal.


\begin{lstlisting}[linewidth=23em]
"this is a string literal"

""

"She said: ""Bye bye"" and left."

"this is a string literal

with a line break in it"
\end{lstlisting}

SMT-LIB string literals are akin to \emph{raw strings} 
in certain programming languages.
However, they have only one escape sequence: \ter{""} .
This means, for example and in contrast to most programming languages, 
that within a \nter{string} the character sequences
\verb+\n+, \verb+\012+, \verb+\x0A+, and \verb+\u0008+
are \emph{not} escape sequences (all denoting the new line character),
but regular sequences denoting their individual characters.\endnote{
This is to achieve maximum generality and independence 
from programming language conventions.
This way, SMT-LIB theories of strings that use string literals 
as constant symbols have the choice to define certain string constants,
such as \ter{"$\backslash$n"} and \ter{"$\backslash$012"},
as equivalent or not.
If we used, say, C-style backslash-prefixed escape sequences 
at the SMT-LIB level, it would be impractical and possibly confusing 
to represent literally certain sequences of characters.
For instance, with C-style conventions the literals 
\ter{"$\backslash\backslash$e"} and \ter{"$\backslash$e"} would be parsed
as the same two-character literal consisting of the characters 
\hex{5C} and \hex{65}.
To represent the three-character string literal consisting of the characters 
\hex{5C}\hex{5C}\hex{65},
one would have to write, for instance, something like
\ter{"$\backslash$$\backslash$$\backslash$e"}
or 
\ter{"$\backslash$x5C$\backslash$e"}.
}

\item[Reserved words.]
The language uses a number of reserved words, sequences of printable characters 
that are to be treated as individual tokens.
The basic set of reserved words consists of the following:
\begin{center}
 \ter{BINARY} \quad 
 \ter{DECIMAL} \quad
 \ter{HEXADECIMAL} \quad
 \ter{NUMERAL} \quad
 \ter{STRING} \\[2ex]
 \verb|_| \quad
 \ter{!} \quad
 \ter{as} \quad
 \ter{\new{lambda}} \quad
 \ter{let} \quad
 \ter{exists} \quad
 \ter{forall} \quad
 \ter{match} \quad
 \ter{par}
\end{center}
%
Additionally, each command name in the scripting language defined in Section~\ref{sec:scripts} 
(\ter{set-logic}, \ter{set-option}, \ldots) is also a reserved word.\endnote{
Strictly speaking, command names do not need to be reserved words
because of the language's namespace conventions.
Having them as reserved words, however, simplifies the creation of compliant parsers
with the aid of parser generators such as Lex/YACC and ANTLR.
}

The syntactic category \nter{reserved} denotes any reserved word.

\item[Symbols.]
A \nter{symbol} is either a simple symbol or a quoted symbol.
A \define{simple symbol} is any non-empty sequence of elements of \nter{letter} and 
\nter{digit} and the characters
\begin{center}
\verb|~ ! @ $ % ^ & * _ - + = < > . ? /|
\end{center}
that does not start with a digit and is not a reserved word.\footnote{%
Note that simple symbols cannot contain non-English letters.
}

\begin{lstlisting}[linewidth=25.5em]
 +  <=  x plus ** $ <sas  <adf> 
 
 abc77 *$s&6   .kkk   .8   +34   -32 
\end{lstlisting}

A \define{quoted symbol} is any sequence of whitespace characters and printable characters
that starts and ends with \verb+|+ and does not contain \verb+|+ or \verb+\+ .\endnote{
Backslash is disallowed in quoted symbols just for simplicity.
Otherwise, for Common Lisp compatibility they would have to be treated
as an escaping symbol (see Section 2.3 of~\cite{Ste-90}).
}
\smallskip

\newpage
\begin{lstlisting}[linewidth=25.5em]
|this is a quoted symbol|

|so is 
 this one|

||

| " can occur too|

|af klj^*0asfe2(&*)&(#^$>>>?"']]984|
\end{lstlisting}

Symbols are case sensitive.
They are used mainly as operators or identifiers.
Conventionally, arithmetic characters and the like are used, 
individually or in combination, as operator names;
in contrast, alpha-numeric symbols, possibly with punctuation characters and underscores, are used as identifiers.
But, as in LISP, this usage is only recommended (for human readability),
not prescribed.
For additional flexibility, arbitrary sequences of whitespace and printable characters 
(except for \verb+|+ and \verb+\+)
enclosed in vertical bars are also allowed as symbols.
Following Common Lisp's conventions, 
\emph{enclosing a simple symbol in vertical bars does not produce a new symbol}.
This means for instance that \ter{abc} and \ter{|abc|} are the \emph{same} symbol.

Simple symbols starting with the character
\ \ter{@} \ or \ \ter{.} \  are reserved for solver use.\footnote{%
This includes symbols such as \ter{|@abc|} and \ter{|.abc|}
which are considered the same as \ter{@abc} and \ter{.abc}, respectively.
}
Solvers can use them respectively as identifiers for abstract values and
solver-generated function symbols other than abstract values.


\item[Keywords.]
A \nter{keyword} is
%a non-empty sequence of elements of \nter{letter} and \nter{digit} and 
%the characters
%\begin{center}
%\verb'~ ! @ $ % ^ & * _ - + = < > . ? /'
%\end{center}
%preceded by a colon (\ter{:}).
a token of the form {\ter{:}}\nter{simple\_symbol} .
Elements of this category have a special use in the language.
They are used as \emph{attribute} names or \emph{option} names (see later).

\begin{lstlisting}[linewidth=15em]
:date   :a2   :foo-bar
:<=     :56   :->
\end{lstlisting}
\end{description}




%-------------------------------------------------------------------------------
\section{S-expressions}
%-------------------------------------------------------------------------------

An S-expression is either a non-parenthesis token or 
a (possibly empty) sequence of S-ex\-press\-ions enclosed in parentheses.
Every syntactic category of the SMT-LIB language is a specialization
of the category \nter{s\_expr} defined by the production rules below.
\bigskip

\sexpressions
\bigskip

\begin{remark}[Meaning of special constants]
Elements of the \nter{spec\_constant} category do not always have the expected
associated semantics in the SMT-LIB language
(i.e., elements of \nter{numeral} denoting integers, 
elements of \nter{string} denoting character strings, and so on).
In particular, in the \nter{term} category (defined later) they simply denote
constant symbols, with no fixed, predefined semantics.
Their semantics is determined locally by each SMT-LIB theory that uses them.
For instance, it is possible for an SMT-LIB theory of sets to use 
the numerals \ter{0} and \ter{1} to denote respectively the empty set and 
universal set.
Similarly, the elements of \nter{binary} may denote integers modulo $n$ 
in one theory and binary strings in another;
the elements of \nter{decimal} may denote rational numbers in one theory and 
floating point values in another.
\end{remark}



%-------------------------------------------------------------------------------
\section{Identifiers} \label{sec:identifiers}
%-------------------------------------------------------------------------------

Identifiers are used mostly as function and sort symbols.
When defining certain SMT-LIB theories 
it is convenient to have indexed identifiers as well.
Instead of having a special token syntax for that,
indexed identifiers are defined more systematically 
as the application of the reserved word \verb+_+
to a symbol and one or more \emph{indices}.
Indices can be numerals or symbols.\endnote{
Symbols were added as indices in Version 2.6 for increased flexibility.
}
\bigskip

\cIdentifiers
\bigskip

\begin{lstlisting}[linewidth=38em]
plus    +       <=    Real   |John Brown|
(_ vector-add 4 5)  (_ BitVec 32)
(_ move up)  (_ move down)  (_ move left)  (_ move right)
\end{lstlisting}

We refer to identifiers from \nter{symbol} as \define{simple} identifiers
and to the others as \define{indexed} identifiers.
Since identifiers are used as the names of function symbols, sort symbols,
\new{sort parameters, (term) variables} and commands, 
we often refer to them informally as \define{names} in this document.
  
\begin{remark}[Namespaces and shadowing of identifiers]
There are several namespaces for identifiers:
sorts, terms, command names, and attributes. 
The same identifier can occur in different namespaces with no risk of conflicts
because each namespace can always be identified syntactically.
Within the term namespace, bound variables can shadow one another as well as
function symbols in accordance with a lexical scoping discipline described 
in Section~\ref{sec:concrete-terms}. 
Similarly, sort parameters can shadow user sort symbols,
as described in Section~\ref{sec:new-symbols}.
\end{remark}
%\cbrem{We haven't introduced the notion of a sort variable yet.}
%%CT We have not introduce the notion of term variable either. 
%%   I have added sort variables in the list from the previous paragraph.


%-------------------------------------------------------------------------------
\section{Attributes}
%-------------------------------------------------------------------------------

Several syntactic categories in the language contain \define{attributes}.
These are generally pairs consisting of an attribute name and an associated value,
although attributes with no value are also allowed.

Attribute names belong to the \nter{keyword} category. 
Attribute values are in general S-expressions other than keywords,
although most predefined attributes use a more restricted category for 
their values.
\bigskip

\cAttributes
\bigskip

\begin{lstlisting}[linewidth=21em]
:left-assoc      
:status unsat
:my_attribute (humpty dumpty)
:authors "Jack and Jill"
\end{lstlisting}

%\bigskip


%-------------------------------------------------------------------------------
\section{Sorts} \label{sec:concrete-sorts}
%-------------------------------------------------------------------------------

A major subset of the SMT-LIB language is 
the language of \emph{well-sorted} terms,
used to represent logical expressions.
Such terms are typed, or \define{sorted} in first-order logic terminology; 
that is, each is associated with a (unique) \define{sort}.
The set of sorts consists itself of \define{sort terms}.
In essence, a sort is 
a \define{sort symbol},
a \define{sort parameter}, 
or a sort symbol applied to a sequence of sort terms.

Syntactically, a sort symbol can be either the distinguished symbol \ter{Bool}
or any \nter{identifier}. 
A sort parameter can be any \nter{symbol} 
(which in turn, is an \nter{identifier}).
\bigskip

\cSorts
\medskip

\begin{lstlisting}[linewidth=35em]
Int                         Bool

(_ BitVec 3)                (List (Array Int Real))

((_ FixedSizeList 4) Real)  (Set (_ Bitvec 3))       

(-> Int Real)               (-> Int (-> Int Real))
\end{lstlisting}

\begin{newver}
A \define{monomorphic} sort is a sort containing no parameters.
A \define{polymorphic} sort is a sort containing zero or more parameters.
For instance, if \ter{X} and \ter{Y} are sort parameters,
and \ter{Int} and \ter{Array} are sort symbols, 
then \ter{(Array Int Int)} is a monomorphic sort 
while \ter{(Array Int Y)}, \ter{(Array X Int)}, and \ter{(Array X Y)} are
all polymorphic sorts.
Note that we treat monomorphic sorts as a special case of polymorphic ones;
hence, \ter{(Array Int Int)} is also a (trivially) polymorphic sort.
Contextual information is needed in general to know whether a particular symbol
occurring in a sort is a sort parameter or not.
Local sort parameters are introduced by a specific binder, \ter{par}.
Global sort parameters are declared in a script by the command \ter{declare-sort-parameter}
(see Section~\ref{sec:new-symbols}).

We will write just \emph{sort} to mean a polymorphic sort, and 
write instead \emph{monomorphic sort} when we want to emphasize 
that the sort has no parameters. 
We will use $\sigma$ to denote monomorphic sorts and 
$\tau$ to denote, more generally, polymorphic sorts.
\end{newver}

\subsection{Ranks}

Each function symbol in an SMT-LIB script is associated with one or more 
\define{ranks}, non-empty sequences of sorts.
Intuitively, a function symbol $f$ with rank $\sigma_1\cdots\sigma_n\sigma$,
(with monomorphic sorts),
denotes a function that takes as input $n$ values of respective sorts
$\sigma_1, \ldots, \sigma_n$,
and returns a value of sort $\sigma$.

In contrast, a function symbol $f$ with rank $\tau_1\cdots\tau_n\tau$,
where each sort may contain sort parameters,
actually stands for a whole \emph{class} of function symbols, 
all named $f$ and each with a rank obtained from $\tau_1\cdots\tau_n\tau$ 
by instantiating in all possible ways every occurrence in $\tau_1\cdots\tau_n\tau$
of a sort parameter with a monomorphic sort.


%-------------------------------------------------------------------------------
\section{Terms and Formulas} \label{sec:concrete-terms}
%-------------------------------------------------------------------------------

Abstractly, terms are constructed out of 
constant symbols in the \nter{spec\_constant} category
(numerals, decimals, strings, etc.),
\define{variables}, 
\define{function symbols}, 
four kinds of \define{binders} 
(introduced by the reserved words \ter{\new{lambda}}, \ter{let}, \ter{forall}, \ter{exists}, and \ter{match}),
and an annotation operator: the reserved word \ter{!}.
In its simplest form, a term is 
a special constant symbol,
a variable,
a function symbol,
or the application of a function symbol to one or more terms.
More complex terms include one or more binders.

Concretely, a variable can be any \nter{symbol},
while a function symbol can be any \nter{identifier}
(i.e., a symbol or an indexed symbol).
As a consequence, contextual information is needed during parsing
to know whether an identifier is to be treated as a variable or 
a function symbol. 
For variables, this information is provided by the binders 
\ter{let}, \ter{\new{lambda}}, \ter{forall}, \ter{exists}, and \ter{match}, 
which are the only mechanism to introduce variables.
Function symbols, in contrast, are predefined, as explained later.
Recall that every function symbol $f$ is separately associated 
with one or more ranks,
each specifying the sorts of $f$'s arguments and result.
To simplify sort checking,
a function symbol in a term can be annotated with one of its result sorts $\tau$.
Such an annotated function symbol is a \define{qualified identifier}
of the form \expr{(as $f$ $\tau$)}.
\bigskip

\cTerms
\bigskip

\begin{newver}
Terms are members of the syntactic category \nter{term}.
Note that sort terms occur within terms containing binders or qualified identifiers.
These sort terms may contain sort parameters, 
which must be declared in a script by the command \ter{declare-sort-parameter}
(see Section~\ref{sec:new-symbols}).
\end{newver}
  
% We refer informally to members of \nter{pterm} as \define{polymorphic} terms.
% We remark that although members of \nter{term} are also polymorphic terms or 
% can occur as subterms of polymorphic terms, the opposite is not the case.\endnote{
% This restriction is intentional, to enforce \emph{prenex} polymorphism~\ref{} \todo{Add reference},
% a limited form of polymorphism that is general enough for our purposes.


SMT-LIB scripts can contain only \define{well-sorted} terms
(see Section~\ref{well-sortedness}).
Formulas in SMT-LIB are just well-sorted terms of sort \ter{Bool}
 (see Section~\ref{sec:core}).
As a consequence, there is no syntactic distinction 
between function and predicate symbols;
the latter are simply function symbols whose result sort is \ter{Bool}.
Another consequence is that function symbols can take formulas 
(even quantified ones) as arguments.

\begin{lstlisting}[linewidth=29em]
(forall ((x (List Int)) (y (List Int)))
  (= (append x y)
    (ite (= x (as nil (List Int)))
      y
      (let ((h (head x)) (t (tail x)))
        (insert h (append t y))))))
\end{lstlisting}


%-------------------------------------------------------------------------------
\subsection{Variable Binders}  \label{sec:binders}
%-------------------------------------------------------------------------------

\begin{newver}

Variables are introduced by means of one of the five binders.
Each binder allows the introduction of one or more variables with local scope.

\paragraph{Lambda.}


This binder corresponds to the abstraction binder of higher-order logic.
It takes a non-empty list of variables, 
which abbreviates a sequential nesting of lambda abstractions.
Specifically, a term of the form

\begin{equation} \label{eq:lambda}
  \expr{
  (lambda (($x_1$ $\tau_1$) ($x_2$ $\tau_2$) $\cdots$ ($x_n$ $\tau_n$)) 
    $t$)
  }
\end{equation}
has the same semantics as the term
%
  \begin{equation} \label{eq:nested-lambda}
  \expr{
   (lambda (($x_1$ $\tau_1$)) 
   (lambda (($x_2$ $\tau_2$)) ($\cdots$ 
   (lambda (($x_n$ $\tau_n$)) $t$) $\cdots$)))
  }
  \end{equation}
  %
  See Section~\ref{sec:core} for more details on the use of this binder.

\end{newver}

\paragraph{Exists and forall quantifiers.}
These binders correspond 
to the usual universal and existential quantifiers of first-order logic,
except that each variable they quantify is also associated with a sort.
Both binders have a non-empty list of variables, 
which abbreviates a sequential nesting of quantifiers.
Specifically, a formula of the form
%
\begin{equation} \label{eq:forall}
\expr{
(forall (($x_1$ $\tau_1$) ($x_2$ $\tau_2$) $\cdots$ ($x_n$ $\tau_n$)) 
  $\varphi$)
}
\end{equation}
%
has the same semantics as the formula
%
\begin{equation} \label{eq:nested-forall}
\expr{
 (forall (($x_1$ $\tau_1$)) 
 (forall (($x_2$ $\tau_2$)) ($\cdots$ 
 (forall (($x_n$ $\tau_n$)) $\varphi$) $\cdots$)
}
\end{equation}
%
Note that the variables in the list 
\expr{(($x_1$ $\tau_1$)\ ($x_2$ $\tau_2$) $\cdots$ ($x_n$ $\tau_n$))}
of (\ref{eq:forall}) are not required to be pairwise disjoint.
However, because of the nested quantifier semantics, earlier occurrences 
of same variable in the list are shadowed by the last occurrence---making 
those earlier occurrences useless.
The same argument applies to the \ter{exists} binder.

\paragraph{Let.}
The \ter{let} binder introduces and defines 
one or more local variables \emph{in parallel}.
Semantically, a term of the form
%
\begin{equation} \label{eq:let}
\expr{(let (($x_1$ $t_1$) $\cdots$ ($x_n$ $t_n$)) $t$)}
\end{equation}
%
is equivalent to the term $t[t_1/x_1, \ldots, t_n/x_n]$ obtained from $t$ 
by simultaneously replacing each free occurrence of $x_i$ in $t$ by $t_i$, 
for each $i=1,\ldots,n$,
possibly after a suitable renaming of $t$'s bound variables 
to avoid capturing any variables in $t_1, \ldots, t_n$.
Because of the parallel semantics, 
\emph{the variables $x_1, \ldots, x_n$ in (\ref{eq:let}) must be pairwise distinct}.

\begin{remark}[No sequential version of \ter{let}]
The language does not have a sequential version of \ter{let}.
Its effect is achieved by nesting lets, as in 
\expr{(let (($x_1$ $t_1$)) (let (($x_2$ $t_2$)) $t$))}.
\qed
\end{remark}

\paragraph{Match.}
Similarly to pattern matching statements in functional programming languages
or in certain interactive theorem provers,
the \ter{match} binder is used to perform pattern matching on values 
of an algebraic data type (see Section~\ref{sec:new-symbols}).
It has the form
%
\begin{equation} \label{eq:match}
\expr{(match $t$ (($p_1$ $t_1$) $\cdots$ ($p_{m+1}$ $t_{m+1}$)))}
\end{equation}
%
where $t$ is a term of some datatype sort $\delta$ and,
for each $i=1,\ldots,m+1$,
$p_i$ is a \define{pattern} for $\delta$, and $t_i$ a term of some sort $\tau$.
A pattern $p$ in turn is either a variable $x$ of sort $\delta$, 
\new{the special variable \ter{\_}},
a nullary constructor $c$ of $\delta$, 
or a term of the form \expr{($c$ $x_1$ $\cdots$ $x_k$)},
where $c$ is a constructor of $\delta$ of rank
$\tau_1\cdots\tau_k\delta$ 
with $k > 0$, and $x_1, \ldots, x_k$ are \emph{distinct} variables 
of respective sort $\tau_1,\ldots,\tau_k$.\endnote{
The sorts of pattern variables are not specified explicitly
since they can be readily inferred from the datatype.
}
\begin{newver}
An exception is the special variable \ter{\_} which can only occur 
in place of one or more of the variables $x_1, \ldots, x_k$.
This variable acts as a wildcard, with each occurrence matching any term
of any sort, hence effectively behaving as a fresh variable.
\end{newver}

The list $p_1,\ldots p_{m+1}$ may contain more than one pattern with the same constructor 
or more than one pattern consisting of a variable.\endnote{
Such lists are semantically redundant in the sense that some of the cases 
can be dropped without affecting its meaning.
This is allowed to simplify parsing.
}
However, it \emph{must} contain a pattern consisting of a variable,
unless every constructor of $\delta$ occurs in one of the patterns.\endnote{
This guarantees that the match expressions are always well defined
(see Section~\ref{sec:models}).
}
\begin{newver}
The recommended choice for a single variable pattern is \ter{\_}; the use of
other variables will be deprecated in future versions.\endnote{This is to avoid
the situation where a typo while attempting to write a nullary constructor introduces a variable pattern, thus
changing the meaning of the match term without warning or error.}
\end{newver}

%For the expression~(\ref{eq:match}) to be well-formed
%the list $p_1,\ldots p_n$ must satisfy these additional requirements:\footnote{%
%Intuitively, these requirements guarantee that the term $t$ matches 
%exactly one pattern.
%}
%\begin{enumerate}
%\item 
%the constructors occurring in the patterns must be mutually distinct;
%\item 
%only $p_n$, the last pattern, can be a variable;
%\item 
%unless $p_n$ is a variable,
%every constructor of $\delta$ must occur in one of the patterns.
%\end{enumerate}

The term $t_i$ in~(\ref{eq:match}) can contain free occurrences 
of the variables occurring in pattern $p_i$, if any.
The scope of those variables is the term $t_i$.

\begin{lstlisting}[linewidth=29em]
; Axiom for list append: version 1
; List is a polymorphic datatype 
; with constructors "nil" and "cons"
;
(forall ((l1 (List Int)) (l2 (List Int)))
  (= (append l1 l2)
     (match l1 (
       (nil l2)
       ((cons h t) (cons h (append t l2)))))))

; Axiom for list append: version 2
(forall ((l1 (List Int)) (l2 (List Int)))
  (= (append l1 l2)
     (match l1 (
       ((cons h t) (cons h (append t l2)))
       (_ l2)))))

; Axiom for list length
(forall ((l (List Int)))
  (= (length l)
     (match l (
       (nil 0)
       ((cons _ t) (length t))))))
\end{lstlisting}

\begin{remark}[No nested patterns]
\define{Nested} patterns, where the arguments of a constructor can be themselves
non-variable patterns, are not allowed.\endnote{
The restriction to flat patterns is for simplicity and may be lifted in later versions.
}
This implies in particular that in a pattern of the form \expr{($c$ $s_1$ $\cdots$ $s_k$)},
where $s_1, \ldots, s_k$ are symbols, those symbols are \emph{always} to be parsed as variables.
\qed
\end{remark}

\begin{newver}
\begin{remark}[Double use of \ter{\_}]
The special symbol \ter{\_} is used both to construct index terms 
and as a wildcard symbol in \ter{match} patterns.
These two different uses can always be disambiguated syntactically
since \ter{\_} occurs in a function symbol position in the first case 
(e.g., in \expr{(\_ BitVec 5)})
and in an argument position in the second case
(e.g., in \expr{(cons h \_)}, \expr{(cons \_ t)}, or \expr{(cons \_ \_)}).
\end{remark}
\end{newver}

Strictly speaking, the \ter{match} binder is not essential 
since it can be defined in terms of the other binders. 
Specifically, expression (\ref{eq:match})
can be written equivalently as follows.
\begin{enumerate}
\item 
\new{
If the match statement contains one or more occurrences of \expr{\_}, 
each of them is replaced by a fresh variable.
}
\item
Suppose that for all $i=1,\ldots, m + 1$, the pattern $p_i$ has the form
\expr{($c_i$ $x_{i,1}$ $\cdots$ $x_{i,k_i}$)} with $k_i>0$;
$q_i$ is the associate tester for that constructor; and
$s_{i,1}, \ldots, s_{i,k_i}$ are the selectors associated, in order,
with the constructor's arguments.
Then, match expression (\ref{eq:match}) has the same meaning as 
%
\begin{equation} \label{eq:match-alt}
\begin{array}{l}
\expr{(ite ($q_1$ $t$) 
 (let (($x_{1,1}$ ($s_{1,1}$ $t$)) $\cdots$ ($x_{1,k_1}$ ($s_{1,k_1}$ $t$))) $t_1$)}
\\
\expr{ (ite ($q_2$ $t$) 
 (let (($x_{2,1}$ ($s_{2,1}$ $t$)) $\cdots$ ($x_{2,k_2}$ ($s_{2,k_2}$ $t$))) $t_2$)}
\\
\quad \expr{ $\cdots$}
\\
\quad\quad\expr{(ite ($q_m$ $t$) 
 (let (($x_{m,1}$ ($s_{m,1}$ $t$)) $\cdots$ ($x_{m,k_m}$ ($s_{m,k_m}$ $t$))) $t_m$)}
\\
\quad\quad\expr{ (let (($x_{m+1,1}$ ($s_{m+1,1}$ $t$)) $\cdots$ ($x_{m+1,k_{m+1}}$ ($s_{m+1,k_{m+1}}$ $t$))) $t_{m+1}$) $\cdots$ ) }
\end{array}
\end{equation}

\item 
When for some $i \in \{1,\ldots, m + 1\}$, the pattern $p_i$ is a nullary constructor, 
the corresponding \ter{let} subexpression in (\ref{eq:match-alt}) is replaced 
by $t_i$.

\item 
If instead for some minimal $i \in \{1,\ldots, m + 1\}$, the pattern $p_i$ is
a variable $x$, then the whole $i$th \ter{ite} subexpression of (\ref{eq:match-alt}),
if $i\leq m$, 
or the \ter{let} subexpression, if $i=m + 1$, is replaced by \expr{(let (($x$ $t$)) $t_i$)}.
\end{enumerate}


%%-------------------------------------------------------------------------------
%\subsection{Parameter Binders}
%%-------------------------------------------------------------------------------
%
%SMT-LIB allows the declaration of polymorphic function symbols 
%in theory declarations (see Section~\ref{sec:theory-declarations}) and 
%of polymorphic datatypes in user scripts (see Section~\ref{sec:new-symbols}).
%\new{
%It also enables the assertion of formulas in user scripts 
%(see Section~\ref{sec:assert})
%containing terms of polymorphic sort.
%}
%Sort parameters are introduced with expressions of the form
%\begin{center}
% \expr{(par ($u_1$ $\cdots$ $u_k$) $e$)}
%\end{center}
%where $u_1, \ldots, u_k$ are $k>0$ pairwise distinct sort parameters and
%$e$ is an expression containing zero or more occurrences of $u_1, \ldots, u_k$.
%\new{
%When $e$ is a term of sort \ter{Bool} the expression above is a formula
%with polymorphic types over the parameters, i.e., sort variables, $u_1, \ldots, u_k$.
%Note that, the way \nter{pterm} is defined (see Section~\ref{sec:concrete-terms}),
%only \emph{prenex} (or \emph{rank-1}) polymorphism is allowed in formulas.\endnote{%
%This restriction is intentional, to simplify reasoning.
%}}

%-------------------------------------------------------------------------------
\subsection{Scoping of variables} \label{sec:free}
%-------------------------------------------------------------------------------


The notions of \define{free} variable occurrence in an s-expression,
\define{bound} variable, and \define{(binder) scope} are defined as follows.
\smallskip

\noindent A variable $x$:
\begin{itemize}
\item
occurs free in the expression $x$;
\item
occurs free in an expression \expr{($e_1$ $\cdots$ $e_n$)}
if $e_1$ is \ter{par} or not a binder, and 
$x$ occurs free in some $e_i$ ($1\le i\le n$); 
\item
occurs free in an expression 
\new{
\expr{($Q$ (($x_1$ $\sigma_1$) $\cdots$ ($x_n$ $\sigma_n$)) $t$)},
where $Q$ is \ter{lambda}, \ter{forall}, or \ter{exists},
if it does not occur in $\{x_1, \ldots, x_n\}$ and occurs free in $t$;}
\item
occurs free in an expression 
\expr{(let (($x_1$ $t_1$) $\cdots$ ($x_n$ $t_n$)) $t$)} if 
$(i)$ it occurs free in some $t_i$ ($1\le i\le n$) and 
the corresponding $x_i$ occurs free in $t$, or 
$(ii)$ it does not occur in $x_1, \ldots, x_n$ and occurs free in $t$;
\item
occurs free in an expression
\expr{(match $t$ (($p_1$ $t_1$) $\cdots$ ($p_n$ $t_n$)))}
if it occurs free in $t$ or it occurs free in some $t_i$ ($1\le i\le n$) and
does not occur in the corresponding $p_i$.
\end{itemize}

%\noindent A parameter $u$:
%\begin{itemize}
%\item
%occurs free in the expression $u$;
%\item
%occurs free in an expression \expr{($e_1$ $\cdots$ $e_n$)}
%if $e_1$ is not \ter{par} and $u$ occurs free in some $e_i$ ($1\le i\le n$); 
%%\item
%%occurs free in an expression
%%\expr{(par ($u_1$ $\cdots$ $u_n$) $e$)}
%%if it occurs free in $e$ and does not occur in \expr{($u_1$ $\cdots$ $u_n$)}.
%\end{itemize}

\noindent 
Each non-free, or \define{bound}, occurrence of a variable 
in an expression has a \define{scope} defined as follows.

\begin{itemize}
\item
In an expression 
\expr{($Q$ (($x_1$ $\sigma_1$) ($x_2$ $\sigma_2$) $\cdots$ ($x_n$ $\sigma_n$)) $t$)} 
where $Q$ is either the binder \ter{\new{lambda}}, \ter{forall}, or \ter{exists}, 
or in an expression \expr{(let (($x_1$ $t_1$) $\cdots$ ($x_n$ $t_n$)) $t$)},
the scope of each variable in $\{x_1, \ldots, x_n\}$ is the term $t$.
\item
In an expression 
\expr{(match $t$ (($p_1$ $t_1$) $\cdots$ ($p_n$ $t_n$)))},
the scope of each variable occurring in pattern $p_i$ is the corresponding term $t_i$
($1\le i\le n$).
%\item
%In an expression 
%\expr{(par ($u_1$ $\cdots$ $u_n$) $e$)},
%the scope of each parameter in $\{u_1, \ldots, u_n\}$ is the expression $e$.
\end{itemize}

%CT REMOVED because incorrect.
%\begin{newver}
%\begin{remark}
%  Since there are no binders for sort parameters in user-scripts,
%  all occurrences of sort parameters in sort terms in user-scripts
%  are free.\endnote{
%    This effectively enforces a restriction to rank-1 polymorphism
%    in the language.}
%\end{remark}
%\end{newver}

\paragraph{Shadowing}
All binders follow a lexical scoping discipline, 
consistent with the semantics of the SMT-LIB logic,
as described in Section~\ref{sec:models}.
In particular, a bound variable will shadow any variable or user-defined 
function symbol with the same name from an enclosing scope.
For instance, in a term like
%\begin{center}
\expr{(forall ((a Int)) (> (+ a 1) 0))},
%\end{center}
variable \expr{a} would shadow any user-declared function symbol
called \expr{a}.
% Similarly, a parameter will shadow any user-defined 
% sort symbol with the same name.
% For instance, in a function symbol declaration like
% %\begin{center}
% \expr{(par (A) (f (Array A B) A))},
% %\end{center}
% all occurrences of \ter{A} are sort parameters regardless of the existence
% of a previously user-declared sort symbol \ter{A}, whereas \ter{B} must
% be either a user- or theory-declared sort symbol.\endnote{
% This shadowing rule follows common lexical scoping conventions.
% It is easy to avoid declarations like \expr{(par (A) (f (Array A B) A))},
% which are potentially confusing to human readers if \ter{A}
% is a user-declared sort symbol,
% simply by a more judicious choice of parameter names.
% %In patterns like \expr{(cons x nil)} are problematic 
% }
% PF Moved to where parametric symbols are declared.
Similarly, in a \ter{match} pattern like \expr{(cons x nil)},
the symbol \ter{nil} is a variable regardless of the existence 
of a previously defined constructor symbol \ter{nil}.\footnote{%
Note that a pattern \expr{(cons x nil)}, where \ter{nil} is a constructor,
would be nested, which is not allowed. 
}

\begin{remark}[No shadowing of theory symbols]
One exception to the shadowing rule above is that binders cannot shadow \define{theory function or sort symbols},
that is, function or sort symbols from the declaration 
(see Section~\ref{sec:theory-declarations})
of a theory included in the current logic
(see Section~\ref{sec:logic-declarations} and Subsection~\ref{sec:restarting}).
In other words, variables cannot have the same name 
as a function symbol declared in the current logic, and sort parameters
(see Section~\ref{sec:new-symbols})
cannot have the same name as a sort symbol declared in the current logic.\endnote{
The reason for this exception is mostly historical. 
Many SMT solvers apply this restriction, possibly under the assumption
that shadowing a theory symbol is, more often than not, unintended and 
so best treated as an error.
}
\end{remark}
%CT Address
%\cbrem{It's now confusing to talk sort
%  parameters here, since we haven't yet discussed the rules for shadowing of sort parameters.}

\subsection{Well-sortedness requirements} \label{well-sortedness}

All terms of the SMT-LIB language are additionally required to be well sorted.
Well-sortedness rules are presented and discussed in Section~\ref{sec:language},
in terms of the logic's abstract syntax.

Except for patterns in \ter{match} expressions,
every occurrence of an \emph{ambiguous} function symbol\footnote{%
That is, function symbols with more than one possible output sort 
for the same sequence of input sorts (see Subsection~\ref{sec:signature}).
}
$f$ in a term \emph{must} occur as a qualified identifier of the form
\expr{(as $f$ $\tau$)} where $\tau$ is the intended output sort
of that occurrence.\endnote{
This restriction eliminates the need for a solver to do sort inference
in order to determine the sorts of terms containing applications 
of ambiguous function symbols.
The use of \ter{as} is not required in patterns because 
there sort inference is needed anyway since pattern variables 
are not explicitly assigned a sort.
}
The same requirement applies to occurrences of solver-generated constants
within terms output by the solver---as the type of these constants is unknown
to the user.

The example below illustrates the need and use of \ter{as} for typical functions
associated with lists or arrays, such as the empty list constructor and the
 constant array constructor.

\begin{lstlisting}[linewidth=35.5em]
; Considering cons and nil as list constructors
(cons "abc" (as nil (List String)))

; Considering a const-array function, taking a value v and
; returning an array storing v at all positions
(= a ((as const-array (Array Int Real)) 0.0))

(select (as @a1 (Array Int Int)) 3)
\end{lstlisting}


%-------------------------------------------------------------------------------
\subsection{Annotations}
%-------------------------------------------------------------------------------
Every term $t$ can be optionally annotated with one or more attributes 
$\alpha_1,\ldots,\alpha_n$
using the wrapper expression \expr{(!~$t$ $\alpha_1\ \cdots\ \alpha_n$)}.
Term attributes have no logical meaning---semantically,
\expr{(!~$t$ $\alpha_1\ \cdots\ \alpha_n$)} is equivalent to $t$---but 
they are a convenient mechanism for adding meta-logical information 
for SMT solvers.

%-------------------------------------------------------------------------------
\subsection{Term attributes}
%-------------------------------------------------------------------------------
Currently there are only two predefined term attributes:
\attr{named} and \attr{pattern}.
The values of the \attr{named} attribute range over the \nter{symbol} category.
The attribute can be used in scripts to give a closed term a symbolic name, 
which can then be used as a proxy for the term (see Section~\ref{sec:commands}).

\begin{lstlisting}[linewidth=20em]
(=> (! (> x y) :named p1)
    (! (= x z) :named p2))
\end{lstlisting}

The values of the \attr{pattern} attribute range over sequences 
of \nter{term} elements.
The attribute is used to define instantiation patterns for quantifiers,
which provide heuristic information to SMT solvers that 
reason about quantified formulas by quantifier instantiation.
Instantiation patterns can only be used to annotate the body $\varphi$ of a quantified formula of the form
\begin{center}
\expr{($Q$ (($x_1$ $\sigma_1$) $\cdots$ ($x_k$ $\sigma_k$)) $\varphi$)}
\end{center}
where $Q$ is \ter{forall} or \ter{exists},
so that the resulting annotated formula has the form
\begin{center}
\begin{tabular}{l@{\ }l}
\expr{($Q$ (($x_1$ $\sigma_1$) $\cdots$ ($x_k$ $\sigma_k$)) 
 (!~$\varphi$} 
 & \expr{:pattern ($p_{1,1}$  $\cdots$ $p_{1,n_1}$)} \\
 & \hspace{4em} \expr{$\vdots$} \\
 & \expr{:pattern ($p_{m,1}$  $\cdots$ $p_{m,n_m}$)))}
\end{tabular}
\end{center}
where each $p_{i,j}$ is a binder-free term with no annotations and
the same well-sortedness requirements as the formula's body.\endnote{
The reason patterns annotate the \emph{body} of a formula they refer to
as opposed to the formula itself, is that, this way, they can use
the body's free variables as pattern variables.
}

%In particular, every variable in $p_{i,j}$ that is not global to the formula 
%must be among $x_1,\ldots, x_k$. 
%\newpage

\begin{lstlisting}[linewidth=31em]
(forall ((x0 A) (x1 A) (x2 A))
  (! (=> (and (r x0 x1) (r x1 x2)) (r x0 x2))
   :pattern ((r x0 x1) (r x1 x2)) 
   :pattern ((p x0 a)) 
  ))
\end{lstlisting}

The intended use of these patterns is to suggest to the solver that it should
try to find independently
for each $i=1,\ldots,m$, a sequence $t_{i,1}$  $\cdots$ $t_{i,n_i}$ of $n_i$ 
ground terms 
that simultaneously match the pattern terms $p_{i,1}$  $\cdots$ $p_{i,n_i}$.\footnote{%
The terms assigned to the variables $x_1, \ldots, x_k$ by the simultaneous 
matching substitution are typically used to instantiate the body 
of a universally quantified formula in order to generate ground consequences 
of that formula.
}

%-------------------------------------------------------------------------------
\section{Theory Declarations} \label{sec:theory-declarations}
%-------------------------------------------------------------------------------

\begin{figure}
\cTheories
\caption{Theory declarations.}
\label{fig:theory-decls}
\end{figure}

The set of SMT-LIB theories is defined by a catalog of \define{theory declarations}
written in the format specified in this section.  
This catalog is available on the SMT-LIB web site at \href{http://www.smt-lib.org}{www.smt-lib.org}.
In earlier versions of the SMT-LIB standard,
a theory declaration defined both a many-sorted \define{signature},
i.e., a collection of sorts and sorted function symbols,
and a theory with that signature.
The signature was determined by the collection 
of individual declarations of sort symbols
and function symbols with an associated \emph{rank}---specifying
the sorts of the symbol's arguments and of its result.

From Version 2.0 on, 
theory declarations may also declare entire families 
of overloaded function symbols by using ranks that contain 
\emph{sort parameters}, locally scoped sort symbols of arity 0. 
This kind of polymorphism entails that a theory declaration generally defines 
a whole \emph{class} of similar theories.

The syntax of theory declarations, specified in Figure~\ref{fig:theory-decls},
follows an attribute-value-based format.
A theory declaration consists of a theory name and a list of \nter{attribute} elements.
Theory attributes with the following keywords are 
\define{predefined attributes}, with prescribed usage and semantics:
\begin{center}
\attr{definition}\qquad
\attr{funs}\qquad
\attr{funs-description}\qquad

\attr{notes}\qquad
\attr{sorts}\qquad
\attr{sorts-description}\qquad
\attr{values} .
\end{center}
Additionally, 
a theory declaration can contain any number of user-defined attributes.\endnote{
\label{user-defined-attributes}
The rationale for allowing user-defined attributes
is the same as in other attribute-value-based languages
(such as, e.g., BibTeX).
It makes the SMT-LIB format more flexible and customizable.
The understanding is that user-defined attributes are allowed
but need not be supported by an SMT solver
for the solver to be considered \emph{SMT-LIB compliant}.
We expect, however, that with continued use of the SMT-LIB format,
certain user-defined attributes will become widely used.
Those attributes might then be officially adopted into the format 
(as non-user-defined attributes) in later versions.
}

Theory attributes can be \emph{formal} or \emph{informal} depending on 
whether or not their values have a formal semantics and can be processed 
in principle automatically.
The value of an informal attribute is free text, 
in the form of a \nter{string} literal or a quoted symbol.
For instance, 
the attributes \attr{funs} and \attr{sorts} are formal in the sense above,
whereas \attr{definition}, \attr{funs-description} and \attr{sorts-description}
are not.

A theory declaration \expr{(theory $T$ $\alpha_1\ \cdots\ \alpha_n$)}
defines a \emph{theory schema} with name $T$ and attributes $\alpha_1, \ldots, \alpha_n$.
Each instance of the schema is a theory $\T_\Sigma$
with an \emph{expanded} signature $\Sigma$,
containing (zero or more) additional sort and function symbols
with respect to those declared in $T$.
Theories are defined as classes of first-order structures (or \define{models})
of signature $\Sigma$.
See Section~\ref{sec:theories} for a formal definition of theories and 
a more detailed explanation of how a theory declaration can be instantiated 
to a theory.
Concrete examples of instances of theory declarations are discussed later.

The value of a \attr{sorts} attribute is a non-empty sequence
of sort symbol declarations \nter{sort\_symbol\_decl}.
A sort symbol declaration \expr{($s$ $n$ $\alpha_1\ \cdots\ \alpha_m$)} declares 
a sort symbol $s$ of arity $n$, and 
may additionally contain zero or more annotations,
each in the form of an \nter{attribute}.
In this version, there are no predefined annotations for sort declarations.

The value of a \attr{funs} attribute is a non-empty sequence
of possibly polymorphic function symbol declarations \nter{par\_fun\_symbol\_decl}.
A (monomorphic)
%CT addressed
%\cbrem{Why monomorphic?  Couldn't it contain a global sort parameter?} 
function symbol declaration \nter{fun\_symbol\_decl}
of the form \expr{($c$ $\sigma$)},
where $c$ is an element of \nter{spec\_constant},
declares $c$ to have sort $\sigma$.
For convenience,
it is possible to declare all the special constants in \nter{numeral} 
to have sort $\sigma$ by means of the function symbol declaration
\expr{(NUMERAL $\sigma$)}.
This is done for instance in the theory declaration in Figure~\ref{fig:Integers}.
The same can be done for the set of \nter{decimal} and \nter{string} constants
by using \ter{DECIMAL} and \ter{STRING}, respectively. 
 
A function symbol declaration of the form
\begin{center}
\expr{($f$ $\sigma_1\ \cdots\ \sigma_n$ $\sigma$)}
\end{center}
with $n \geq 0$ declares a \define{monomorphic function symbol} $f$ with rank 
$\sigma_1\cdots\sigma_n\sigma$,
provided that $\sigma$ and all $\sigma_i$'s are monomorphic sorts.

A function symbol declaration of the form,
\begin{center}
\expr{(par ($u_1\ \cdots\ u_k$) ($f$ $\tau_1\ \cdots\ \tau_n$ $\tau$))}
\end{center}
with $k > 0$, $n \geq 0$ and $u_1, \ldots, u_k$ all distinct,
declares a \define{polymorphic function symbol} $f$ with rank $\tau_1\cdots\tau_n\tau$
provided that $\tau$ and all $\tau_i$'s are polymorphic sorts over 
the (local) parameters $u_1, \ldots, u_k$, where \ter{par} is a binder for
these parameters.
This effectively declares a \emph{class} of function symbols, 
all named $f$ and each with a rank obtained from $\tau_1\cdots\tau_n\tau$ 
by instantiating in all possible ways each occurrence in $\tau_1\cdots\tau_n\tau$
of the sort parameters $u_1,\ldots,u_k$ with monomorphic sorts.

\begin{newver}
Note that a parameter will shadow any sort symbol with the same name.
For instance, in a function symbol declaration like
%\begin{center}
\expr{(par (A) (f (Array A B) A))},
%\end{center}
all occurrences of \ter{A} are sort parameters regardless of the existence
of a previously declared sort symbol \ter{A}, whereas \ter{B} must
be a previously declared sort symbol.\endnote{
This shadowing rule follows common lexical scoping conventions.
It is easy to avoid declarations like \expr{(par (A) (f (Array A B) A))},
which are potentially confusing to human readers if \ter{A}
is a sort symbol,
simply by a more judicious choice of parameter names.
%In patterns like \expr{(cons x nil)} are problematic 
}
\end{newver}
\cbrem{What about shadowing of global sort parameters?}

As with sorts, each function symbol declaration 
may additionally contain zero or more annotations $\alpha_1, \ldots, \alpha_n$,
each in the form of an \nter{attribute}.
In this version, there are only 4 predefined function symbol annotations,
all attributes with no value:
\attr{chainable}, 
\attr{left-assoc},
\attr{right-assoc},
and
\attr{pairwise}. 
The \attr{left-assoc} annotation can be added only 
to function symbol declarations of the form
\begin{center}
\expr{($f$ $\sigma_1$ $\sigma_2$ $\sigma_1$)}
\ or \ 
\expr{(par ($u_1\ \cdots\ u_k$) ($f$ $\tau_1$ $\tau_2$ $\tau_1$))}.
\end{center}
Then, an expression of the form \expr{($f$ $t_1\ \cdots\ t_n$)} 
with $n > 2$ is allowed as syntactic sugar (recursively) for
\expr{($f$ ($f$ $t_1\ \cdots\ t_{n-1}$) $t_n$)}.
Similarly,
the \attr{right-assoc} annotation can be added only 
to function symbol declarations of the form
\begin{center}
\expr{($f$ $\sigma_1$ $\sigma_2$ $\sigma_2$)}
\ or \ 
\expr{(par ($u_1\ \cdots\ u_k$) ($f$ $\tau_1$ $\tau_2$ $\tau_2$))}.
\end{center}
Then, \expr{($f$ $t_1\ \cdots\ t_n$)} with $n > 2$ is syntactic sugar for
\expr{($f$ $t_1$ ($f$ $t_2\ \cdots\ t_n$))}.

The \attr{chainable} and \attr{pairwise} annotations can be added only 
to function symbol declarations of the form
\begin{center}
\expr{($f$ $\sigma$ $\sigma$ Bool)}
\ or \ 
\expr{(par ($u_1\ \cdots\ u_k$) ($f$ $\tau$ $\tau$ Bool))}
\end{center}
and are mutually exclusive.
With the first annotation, 
\expr{($f$ $t_1\ \cdots\ t_n$)} with $n > 2$ is syntactic sugar for
\expr{(and ($f$ $t_1$ $t_2$) ($f$ $t_2$ $t_3$) $\cdots$  ($f$ $t_{n-1}$ $t_n$))}
where \ter{and} is itself a symbol declared as \attr{left-assoc}
in every theory (see Subsection~\ref{sec:theory-examples});
with the second, \expr{($f$ $t_1\ \cdots\ t_n$)} is syntactic sugar 
(recursively) for
\expr{(and ($f$ $t_1$ $t_2$) $\cdots$ ($f$ $t_1$ $t_n$) ($f$ $t_2\ \cdots\ t_n$))}. 
\medskip


\begin{lstlisting}[linewidth=35em]
(+ Real Real Real :left-assoc)

(and Bool Bool Bool :left-assoc)

(par (X) (insert X (List X) (List X) :right-assoc))

(< Real Real Bool :chainable)

(equiv Elem Elem Bool :chainable) 

(par (X) (Disjoint (Set X) (Set X) Bool :pairwise))

(par (X) (distinct X X Bool :pairwise))
\end{lstlisting}
\medskip

For many theories in SMT-LIB, in particular those with a finite signature, 
it is possible to declare all of their symbols
using a finite number of sort and function symbol declarations
in \attr{sorts} and \attr{funs} attributes.
For others, such as, for instance, the theory of bit vectors,
one would need infinitely many such declarations.
In those cases, 
sort symbols and function symbols are defined informally, in plain text,
in \attr{sorts-description}, and \attr{funs-description} attributes,
respectively.\endnote{
\label{why-description-attributes}
See the point made in Note~\ref{why-textual-definitions}.
}

\begin{lstlisting}[linewidth=39em]
:sorts_description
 "All sort symbols of the form  (_ BitVec m)  with m > 0."
\end{lstlisting}

\begin{lstlisting}[linewidth=35em]
:funs_description
 "All function symbols with rank of the form

    (concat (_ BitVec i) (_ BitVec j) (_ BitVec m))

  where i,j > 0 and i + j = m."
\end{lstlisting}
\medskip


The \attr{definition} attribute is meant to contain
a natural language definition of the theory.
While this definition is expected to be as rigorous as possible,
it does not have to be a formal one.\endnote{
\label{why-textual-definitions}
Ideally, 
it would be better if \attr{definition} were a formal attribute,
to avoid ambiguities and misinterpretation and possibly allow
automatic processing.
The choice to use free text for this attribute is for
practical reasons.
The enormous amount of effort that would be needed to first devise 
a formal language for this attribute
and then specify its value for each theory in the library
is not justified by the current goals of SMT-LIB.
Furthermore,
this attribute is meant mainly for human readers,
not programs,
hence a mathematically rigorous definition in natural language
seems enough.
}
For some theories, 
a mix of formal notation and natural language might be more appropriate.
In the presence of polymorphic function symbol declarations,
the definition must also specify the meaning of each instance of the
declared symbol.\endnote{
Version 1.2 allowed one to specify a finitely-axiomatizable theory formally
by listing a set of axioms in an \attr{axioms} attribute.
This attribute is gone from Version 2.0 onwards,
because only one or two theories in the SMT-LIB catalog can be defined that way. 
The remaining ones require infinitely many axioms or axioms with 
quantified sort symbols which are not expressible in the language.
}

The attribute \attr{values} is used to specify, for each sort $\sigma$, 
a distinguished, decidable set of ground terms of sort $\sigma$ 
that are to be considered as \define{values} for $\sigma$.
We will call these terms \define{value terms}.
Intuitively, given an instance theory containing a sort $\sigma$,
$\sigma$'s set of value terms is a set of terms that denotes, 
in each countable model of the theory, all the elements of that sort.
These terms might be over a signature with additional function symbols 
with respect to those specified in the theory declaration.
Ideally, the set of value terms is minimal, which means that 
no two distinct terms in the set denote the same element in some model 
of the theory.
However, this is only a recommendation, not a requirement 
because it is impractical, or even impossible, to satisfy it 
for some theories.
%
%Moreover, the equivalence in the theory of two value terms of the same sort 
%must be decidable---preferably in linear time.\endnote{
%The idea is that is should be easy to tell that two value terms denote
%the same thing.
%For instance, a set of term values of sort \ter{Rational} in the theory 
%of rational numbers could be the set of all terms of the form
%\ter{(/ $m$ $n$)} where $m$ is a numeral and $n$ is a non-zero numeral, and
%\ter{/} and numerals are interpreted in every model of the theory as expected.
%This set satisfies the requirement for being a value term set.
%However, it is not minimal, because it contains distinct equivalent terms
%such as \ter{(/ 1 3)} and \ter{(/ 2 6)}.
%While it is possible and easy to define a minimal value term set in this theory,
%that is not the case in general.
%}
See the next subsection for examples of value sets, and
Section~\ref{sec:logics} for a more in-depth explanation.


The attribute \attr{notes} is meant 
to contain documentation information on the theory declaration 
such as authors, date, version, references, etc.,
although this information can also be provided 
with more specific, user-defined attributes.

\begin{constraint}[Theory Declarations]
\label{def:theory}
The only legal theory declarations of the SMT-LIB language are those 
that satisfy the following restrictions.
\begin{enumerate}
\item
They contain exactly one occurrence of the \attr{definition} and 
the \attr{values} attribute\footnote{%
Which makes those attributes non-optional.
}
and any number of occurrences of other attributes.

\item
Each sort symbol used in a \attr{funs} attribute is 
previously declared in some \attr{sorts} attribute.
In each polymorphic function symbol declaration
\expr{(par ($u_1\ \cdots\ u_k$) ($f$ $\tau_1\ \cdots\ \tau_n$ $\tau$))},
any symbol other than $f$ that is not a previously declared sort symbol
must be one of the sort parameters $u_1, \ldots, u_k$. 

\item
The definition of the theory, provided in the \attr{definition} attribute,
refers only to sort and function symbols previously declared formally
in \attr{sorts} and \attr{funs} attributes or 
informally in \attr{sorts-description} and \attr{funs-description} attributes.

%ct eliminated the item below, because we do not have an :axioms attribute
%\item
%The terms listed in an \attr{axioms} 
%attribute are well-sorted closed formulas
%built with sort and function symbols previously declared
%in \attr{sorts}, \attr{funs}, \attr{sorts-description} and \attr{funs-description} attributes.
\end{enumerate}
\end{constraint}

Note that the \attr{funs} attribute is optional in a theory declaration
because a theory might lack function symbols (although 
such a theory would not be not very interesting).


%-------------------------------------------------------------------------------
\subsection{Examples} \label{sec:theory-examples}
%-------------------------------------------------------------------------------

\subsubsection*{Core theory}

To provide the usual set of Boolean connectives for building formulas,
in addition to the predefined logical symbol \ter{distinct},
a basic core theory is implicitly included in every other SMT-LIB theory.
Concretely, every theory declaration is assumed 
to contain implicitly the \attr{sorts} and \attr{funs} attributes 
of the \ter{Core} theory declaration and 
to define the symbols in those attributes in the same way as in \ter{Core}.
The full Core theory definition is shown in Figure~\ref{fig:Core}.
A more detailed description of this theory is provided in Section~\ref{sec:core}.


%-------------------------------------------------------------------------------
\subsubsection*{Integers}
%-------------------------------------------------------------------------------

\begin{figure}[t]
  \small
  {\color{NavyBlue}
  \begin{verbatim}
  (theory Ints
   :sorts ( (Int 0) )
   :funs ( (NUMERAL Int) 
           (- Int Int)                 ; negation
           (- Int Int Int :left-assoc) ; subtraction
           (+ Int Int Int :left-assoc) 
           (* Int Int Int :left-assoc)
           (<= Int Int Bool :chainable)
           (<  Int Int Bool :chainable)
           (>= Int Int Bool :chainable)
           (>  Int Int Bool :chainable) )
   :definition 
   "For every expanded signature Sigma, the instance of Ints with that
    signature is the theory consisting of all Sigma-models that interpret 
    - the sort Int as the set of all integers,
    - the function symbols of Ints as expected. "
   :values 
   "The Int values are all the numerals and all the terms of the form (- n)
    where n is a non-zero numeral." 
  )
  \end{verbatim}
  }
  \caption{A possible theory declaration for the integer numbers.}
  \label{fig:Integers}
\end{figure}
  
The theory declaration of Figure~\ref{fig:Integers} defines all theories
that extend the standard theory of the (mathematical) integers with additional 
\emph{uninterpreted} sort and function symbols.\footnote{%
For simplicity, the theory declaration in the figure is an abridged version of 
the declaration actually used in the SMT-LIB catalog.
}
The integers theory proper is the instance with no additional symbols.
More precisely,
since the \ter{Core} theory declaration is implicitly included in
every theory declaration,
that instance is the two-sorted theory of the integers and the Booleans.
The set of values for the \ter{Int} sort consists of all numerals and 
all terms of the form \expr{(- $n$)}
where $n$ is a numeral other than $0$.


%-------------------------------------------- -----------------------------------
\subsubsection*{Arrays with extensionality}
%-------------------------------------------------------------------------------

\begin{figure}[h]
\small
{\color{NavyBlue}
\begin{verbatim}
(theory ArraysEx
 :sorts ( (Array 2) )
 :funs ( (par (X Y) (select (Array X Y) X Y))
         (par (X Y) (store (Array X Y) X Y (Array X Y))) )
 :notes
  "A schematic version of the theory of functional arrays with extensionality."
 :definition
  "For every expanded signature Sigma, the instance of ArraysEx with that
   signature is the theory consisting of all Sigma-models that satisfy all 
   axioms of the form below, for all sorts s1, s2 in Sigma:
  
   - (forall ((a (Array s1 s2)) (i s1) (e s2))
       (= (select (store a i e) i) e))
   - (forall ((a (Array s1 s2)) (i s1) (j s1) (e s2))
       (=> (distinct i j) (= (select (store a i e) j) (select a j))))
   - (forall ((a (Array s1 s2)) (b (Array s1 s2)))
       (=> 
         (forall ((i s1)) (= (select a i) (select b i))) (= a b))) "
  :values
   "For all sorts s1, s2, the values of sort (Array s1 s2) are either abstract 
    or have the form (store a i v) where
    - a is value of sort (Array s1 s2),
    - i is a value of sort s1, and 
    - v is a value of sort s2."
)
\end{verbatim}
}%
%
% If s is a sort, let [s] be the set denoted by s in a given model.
% of all Sigma-models where, for all sorts s1, s2 in Sigma:
%  - [Array s1 s2] is the set ([s1] -> [s2]) of all total maps from [s1] to [s2];
%  - (select (Array s1 s2) s1 s2) denotes the function that 
%    for each map m in ([s1] -> [s2]) and i in [s1] returns m(i);
%  - (store (Array s1 s2) s1 s2 (Array s1 s2))) denotes the function that
%    for each map m in ([s1] -> [s2]), i in [s1] and v in [s2] 
%    returns a map that maps i to v and is otherwise identical to m. 
%
\caption{The \ter{ArraysEx} theory declaration.}
\label{fig:ArraysEx}
\end{figure}

A schematic version of the theory of functional arrays with extensionality
is defined in the theory declaration \ter{ArraysEx} in Figure~\ref{fig:ArraysEx}.
Each instance gives a theory of (arbitrarily nested) arrays.
For instance, 
with the addition of the nullary sort symbols \ter{Int} and \ter{Real},
we get an instance theory whose sort set $S$ contains, inductively,
\ter{Bool}, \ter{Int}, \ter{Real} and all sorts of the form
\expr{(Array $\sigma_1$ $\sigma_2$)} with $\sigma_1, \sigma_2 \in S$.
This includes \emph{flat array} sorts such as 
\begin{center}
\expr{(Array Int Int)},
\expr{(Array Int Real)},
\expr{(Array Real Int)},
\expr{(Array Bool Int)},
\end{center}
conventional \emph{nested array} sorts such as 
\begin{center}
\expr{(Array Int (Array Int Real))},
\end{center}
as well as nested sorts such as
\begin{center}
\expr{(Array (Array Int Real) Int), (Array (Array Int Real) (Array Real Int))}
\end{center}
with an array sort in the \emph{index position} of the outer array sort.\endnote{
\label{why-nested-sorts}
One advantage of defining instances of theory declaration schemas 
%cb as in this version
this way is that with one instantiation of the schema
one gets a \emph{single} theory with arbitrarily nested sorts---another 
example being the theory of all nested lists of integers, say,
with sorts \expr{(List Int)}, \expr{(List (List Int))}, etc. 
This is convenient in applications coming from software verification,
where verification conditions can contain arbitrarily nested data types. 
But it is also crucial in providing a simple and powerful mechanism 
for theory combination, as explained later.
}

The function symbols of the theory include 
all symbols with name \ter{select} and rank of the form
\expr{((Array $\sigma_1$ $\sigma_2$) $\sigma_1$ $\sigma_2$)}
for all $\sigma_1, \sigma_2 \in S$. 
Similarly for \ter{store}.


%-------------------------------------------------------------------------------
\subsubsection*{Sets and Relations}
%-------------------------------------------------------------------------------

\begin{figure}
\small
{\color{NavyBlue}
\begin{verbatim}
(theory SetsRelations
 :sorts ( (Set 1) )
 :funs ( (par (X) (emptySet (Set X)))
         (par (X) (univSet (Set X)))
         (par (X) (singleton X (Set X)))
         (par (X) (union (Set X) (Set X) (Set X) :left-assoc))
         (par (X) (inters (Set X) (Set X) (Set X) :left-assoc))
         (par (X) (in X (Set X) Bool))
         (par (X) (subset (Set X) (Set X) Bool :chainable)) )
 :sorts_description
  "All sort symbol declarations of the form (Prod n) with n > 1"
 :funs_description
  "All function symbols with declarations of the form
     (par (X1 ... Xn) (tuple X1 ... Xn (Prod X1 ... Xn)))  
     (par (X1 ... Xn) ((_ project i) (Prod X1 ... Xn) Xi))  
     (par (X1 ... Xn) (prod (Set X1) ... (Set Xn) (Set (Prod X1 ... Xn))))  
   with n > 1 and i = 1,...,n"
 :notes
  "A schematic theory of sets and relations."
 :definition
  "For every expanded signature Sigma, the instance of SetsRelations 
   with that signature is the theory consisting of all Sigma-models that 
   for all sorts s, s1,..., sn, with n > 1, interpret
   - (Set s) as the powerset of the set denoted by s
   - (as emptySet (Set s)) as the empty set of sort (Set s)
   - (as univSet (Set s)) as the set denoted by s
   - (Prod s1 ... sn) as the Cartesian product of the sets denoted by s1,...,sn
   - (tuple s1 ... sn (Prod s1 ... sn)) as the function that maps
     its inputs x1, ..., xn to the tuple (x1, ..., xn) 
   - ((_ project i) (Prod s1 ... sn) si) for i = 1, ..., n as the i-th
     projection function
   - (prod (Set s1) ... (Set sn) (Set (Prod s1 ... sn))) as the function
     that maps its input sets to their Cartesian product
   and interpret the other function symbols as the corresponding set operators
   as expected."
)
\end{verbatim}
}%
\caption{A possible declaration for a theory of sets and relations.}
\label{fig:SetsRelations}
\end{figure}

A schematic many-sorted version of the theory of hereditary well-founded 
sets with urelements is defined in the theory declaration \ter{SetsRelations} 
in Figure~\ref{fig:SetsRelations}.
Each instance gives a theory of sets of elements of the same sort.
These elements can be either atomic (i.e., of a primitive sort like Bool), 
or tuples of elements, or sets themselves.
For instance, with the addition of the nullary sort symbol \ter{Int}
we get an instance theory whose sort set $S$ contains, inductively,
\ter{Bool}, \ter{Int} and all sorts of the form
\expr{(Set $\sigma$)} or \expr{(Prod $\sigma_1$ $\cdots$ $\sigma_n$)}
with $\sigma, \sigma_1, \ldots, \sigma_n \in S$.
In each model of the theory that interprets \ter{Int} as the integers,
we get Booleans, integers, sets of Booleans, sets of integers, 
sets of tuples over these sets, and so on.

%For all sorts $\sigma \in S$,
%the function symbols of the theory include 
%all symbols with:
%name \ter{emptySet} and rank \expr{((Set $\sigma$))};
%name \ter{univSet} and rank \expr{((Set $\sigma$))};
%name \ter{singleton}  and rank \expr{($\sigma$ (Set $\sigma$))};
%name \ter{union}  and rank \expr{((Set $\sigma$) (Set $\sigma$) (Set $\sigma$))};
%and so on.
%
Note that every sort $\sigma$ in the signature is internalized in the theory, 
since the set denoted by $\sigma$ is also denoted 
by the constant \ter{univSet} of (the powerset) sort \expr{(Set $\sigma$)}.


\smallskip
\begin{remark}[Instances of polymorphic sorts]
For some applications, 
the instantiation mechanism defined here for theory declarations
will definitely over-generate.
For instance, it is not possible to define by instantiation of
the \ter{ArraysEx} declaration 
a theory of just the arrays of sort \expr{(Array Int Real)},
without all the other nested array sorts over $\{\ter{Int},\, \ter{Real}\}$.
This, however, is not a problem
because scripts refer to logics, not directly to theories.
And the language of a logic can be always restricted to contain only
a selected subset of the sorts in the logic's theory.
\end{remark}


\section{Core Theory}
\label{sec:core}


\begin{figure}[t]
\small
{\color{NavyBlue}
\begin{verbatim}
(theory Core

 :sorts ( (Bool 0) )

 :funs ( (true Bool)  (false Bool)  (not Bool Bool)
         (=> Bool Bool Bool :right-assoc)  (and Bool Bool Bool :left-assoc)
         (or Bool Bool Bool :left-assoc)  (xor Bool Bool Bool :left-assoc)
         (par (A) (= A A Bool :chainable))
         (par (A) (distinct A A Bool :pairwise))
         (par (A) (ite Bool A A A)) )

 :definition
 "For every expanded signature Sigma, the instance of Core with that signature
  is the theory consisting of all Sigma-models in which: 
  - the sort Bool denotes the set {true, false} of Boolean values;
  - for all sorts s in Sigma, 
    - (= s s Bool) denotes the function that
      returns true iff its two arguments are identical;
    - (distinct s s Bool) denotes the function that
      returns true iff its two arguments are not identical;
    - (ite Bool s s) denotes the function that
      returns its second argument or its third depending on whether 
      its first argument is true or not;
  - the other function symbols of Core denote the standard Boolean operators
    as expected."
  
  :values "The set of values for the sort Bool is {true, false}." 
)
\end{verbatim}
}%
\caption{The \ter{Core} theory declaration.}
\label{fig:Core}
\end{figure}

The core theory is a subtheory of all SMT-LIB theories.
It introduces the basis sort and function symbols of the underlying logic,
which are then automatically available in all theories.
It provides the standard \ter{Bool} sort for Boolean values.
The theory also provides the usual set of Boolean connectives for building formulas,
as well polymorphic function symbols for equality (\ter{=}), disequality (\ter{distinct}), and
if-then-else (\ter{ite}).
Every theory declaration is assumed 
to contain implicitly the \attr{sorts} and \attr{funs} attributes 
of the \ter{Core} theory declaration and 
to define the symbols in those attributes in the same way as in \ter{Core}.




Note the absence of a symbol for double implication.
Such a connective is superfluous 
because the equality symbol \ter{=} can be used in its place. 
Note how the attributes specified in the declarations of the various symbols
of this theory allow one, for instance, to write expressions like 

\begin{center}
\expr{(=> x y z)}
\qquad \expr{(and x y z)}
\qquad \expr{(= x y z)} \\
\expr{(distinct x y z)}
\end{center}

\noindent respectively as abbreviations for the terms

\begin{center}
\expr{(=> x (=> y z))}
\qquad \expr{(and (and x y) z)}
\qquad \expr{(and (= x y) (= y z))} \\
\qquad \expr{(and (distinct x y) (distinct x z) (distinct y z))} .
\end{center}


The simplest instance of \ter{Core} is the theory with no additional sort
and function symbols.
In that theory, there is only one sort, \ter{Bool},
and \ter{ite} has only one rank, \expr{(ite Bool Bool Bool Bool)}.
%\footnote{%
%That \ter{ite} operator plays the role of the \ter{if\_then\_else} connective in Version 1.2.
%}
In other words, this is just the theory of the Booleans with the standard Boolean operators
plus \ter{ite} and \ter{distinct}.
The set of values for the \ter{Bool} sort is, predictably, $\{\ter{true},\ter{false}\}$.

Another instance has a single additional sort symbol \ter{U}, say, 
of arity 0, and a (possibly infinite) set of function symbols 
with rank in \ter{U}$\!^+$.
This theory corresponds to \emph{EUF}, 
the (one-sorted) theory of equality and \emph{uninterpreted functions}
(over those function symbols).
In this theory, \ter{ite} has two ranks:
\expr{(ite Bool Bool Bool Bool)} and \expr{(ite Bool U U U)}.
A many-sorted version of EUF is obtained by instantiating \ter{Core}
with more than one nullary sort symbol---and possibly additional
function symbols over the resulting sort set. 

Yet another instance is the theory with an additional unary sort symbol \ter{List}
and an additional number of function symbols.
This theory has infinitely many sorts:
\ter{Bool}, \ter{(List Bool)},  \ter{(List (List Bool))}, etc.
However, by the definition of \ter{Core},
all those sorts and function symbols are still ``uninterpreted'' in the theory.
In essence, 
this theory is the same as a many-sorted version of EUF with infinitely many sorts.
While not very interesting in isolation,
the theory is useful in combination with a theory of lists that,
for each sort $\sigma$, 
interprets \expr{(List $\sigma$)} as the set of all lists over $\sigma$.
The combined theory in that case is a theory of lists with uninterpreted
functions.

\begin{newver} 

%-------------------------------------------------------------------------------
\section{Higher-order Core Theory}
\label{sec:ho-core}
%-------------------------------------------------------------------------------

\begin{figure}[t]
  \small
  {\color{NavyBlue}
  \begin{verbatim}
  (theory HO-Core
  
   :sorts ( (-> 2 :right-assoc) )
  
   :funs ( (par (A B) (_ (-> A B :left-assoc) A B) ) )
  
   :definition
   "For every expanded signature Sigma, the instance of HO-Core with that signature
    is the theory consisting of all Sigma-models in which: 
    - the sort constructor -> denotes the map sort constructor;
    - for all sorts s1, s2 in Sigma, 
      - (_ (-> s1 s2) s1 s2) denotes the function that
        returns the result of applying its first argument to its second."
    
   :values 
   "For all sorts s1, s2, the set of values for the sort (-> s1 s2) consists of
    - an abstract value for each map (from a countable subset of the maps)
      of type s1 -> s2;
    - terms of the form (lambda ((x s1)) t) where t has sort s2 when every
      free occurrence of x in t has sort s1.
   " 
  )
  \end{verbatim}
  }%
  \caption{The \ter{HO-Core} theory declaration.}
  \label{fig:HO-Core}
  \end{figure}
  

%
% The full language of the theory \ter{SetsRelations} 
% from Figure~\ref{fig:SetsRelations} has the same expressive power as
% higher-order logic or, more precisely, higher-order simple predicate logic
% with primitive types.\footnote{%
% This is a relational version of higher-order logic, as opposed 
% to the functional versions that are more popular in computer science. 
% }
% Higher-order quantification is realized by first-order quantification 
% over sorts of the form \expr{(Set $\sigma$)}.
% Similarly, higher-order predicate symbols can be encoded 
% as unary first-order predicate symbols over sets.
% In fact, because of the presence of the predicate symbol \ter{in}, 
% no additional predicate symbols at all are needed:
% every atomic formula of the form \expr{($p$ $t$)} 
% can be replaced by the formula \expr{(in $t$ $p'$)}
% where $p'$ is a constant symbol of sort 
% \expr{(Set (Prod $\sigma_1$ $\cdots$ $\sigma_n$))}
% if $p$ has rank \expr{((Prod $\sigma_1$ $\cdots$ $\sigma_n$) Bool)}, 
% and of sort \expr{(Set $\sigma$)}
% if $p$ has rank \expr{($\sigma$ Bool)}.

% %-------------------------------------------------------------------------------
% \subsubsection*{Monadic second-order logic}
% %-------------------------------------------------------------------------------
% This logic can be obtained by imposing restrictions on the language
% of the \ter{SetsRelations} theory mentioned above, specifically, 
% by disallowing the use of terms of \ter{Prod} sorts (monadic restriction) or
% nested \ter{Set} sorts (second-order restriction) 
% while, however, allowing additional function and predicate symbols.

This version of SMT-LIB adds support for higher-order logic through the addition
of a new theory, HO-Core of maps, shown in Figure~\ref{fig:HO-Core},
where maps can be understood as total functional relations.\endnote{
We call them \emph{maps} instead of \emph{functions} to distinguish them
from SMT-LIB functions since the two are treated differently in the syntax.
For instance, maps can be passed as arguments while functions cannot. 
}


The theory includes a binary sort constructor \ter{->} for sorts 
that denote sets of maps 
(for example \expr{(-> Int Real)} for the sort of maps from \ter{Int} to \ter{Real})
and an explicit map application operator \ter{\_}.

Note that, with this addition, the language distinguishes 
between unary \emph{functions} denoted by symbols of rank $\tau_1\tau_2$,
and \emph{maps} denoted by constant symbols or variables of sort \expr{(-> $\tau_1$ $\tau_2$)}.
For instance, the latter can be passed as an argument to other functions 
as any other variable but the former cannot.\endnote{%
\new{This difference will disappear in the planned Version 3 of the standard
whose underlying logic will change from many-sorted logic 
to a version of higher-order logic with dependent types.}
}
This is no real limitation, though, because it is possible to convert from one to the other
thanks to the apply operator \ter{\_} and the abstraction binder \ter{lambda}.
For instance, if \ter{f} is a function symbol of rank $\tau_1\tau_2$,
one can define a corresponding map with the command 
(see~\ref{sec:new-symbols}) 
\begin{center}
\expr{(define-const c\_f (lambda ((x $\tau_1$)) (f x)))} .
\end{center}
%
Conversely, if \ter{e} is any expression of sort \expr{(-> $\tau_1$ $\tau_2$)},
the corresponding function can be defined by the command 
\begin{center}
\expr{(define-fun f\_c ((x $\tau_1$)) $\tau_2$ (\_ e x))} .
\end{center}

The \ter{->} sort constructor is defined as right-associative, 
allowing for instance the syntax
\expr{(-> $\tau_1$ $\tau_2$ $\tau_3$)} to be used in place of the syntax
\expr{(-> $\tau_1$ (-> $\tau_2$ $\tau_3$))}.
Correspondingly, the application operator \ter{\_} is defined as left-associative, 
allowing the syntax
\expr{(\_ $t_1$ $t_2$ $t_3$)} to be used in place of the syntax
\expr{(\_ (\_ $t_1$ $t_2$) $t_3$)}.
Note that this also allows the \emph{partial} application \expr{(\_ g t)} 
of a constant \ter{g} of sort \expr{(-> $\tau_1$ $\tau_2$ $\tau_3$)},
which is a term of sort \expr{(-> $\tau_2$ $\tau_3$)}.

As an additional simplification, which does not introduce ambiguities,  
it is possible to omit the \ter{\_} symbol altogether in applications and write
\expr{(g t)} instead of \expr{(\_ g t)}.

\begin{remark}
Note that the SMT-LIB logic remains first-order in syntax:
it is not possible to have a function symbol $g$ of rank $\tau_1 \cdots \tau_n$
(with $n > 1$) as an argument to another function, as in \expr{(f g)}.
The function $g$ has to be encapsulated into a $\lambda$-abstraction first.
For instance, 
if \ter{f} is a function symbol of rank \expr{(-> $\tau_1$ $\tau_2$)\,$\tau$} and
$g$ is a function symbol of rank $\tau_1 \tau_2$,
then the term  \expr{(f (lambda ((x $\tau_1$)) (g x)))} is well sorted, 
and has sort $\tau$.

Similarly, it is not possible to return a function of rank $\tau_1 \cdots \tau_n$
(with $n > 1$) from another function, but it is possible to return
a value of sort \expr{(-> $\tau_1$ $\cdots$ $\tau_n$)}.\endnote{\new{
The difference between functions and maps
will disappear in Version 3 where, in current terms, 
there will be no function symbols but only constant symbols,
possibly of sort \expr{(-> $\tau_1$ $\tau_2$)}.
}}
\end{remark}
\end{newver} 


%-------------------------------------------------------------------------------
\section{Logic Declarations} \label{sec:logic-declarations}
%-------------------------------------------------------------------------------

The SMT-LIB format allows the explicit definition of
sublogics of its main logic--- a version of many-sorted first-order logic with equality---that 
restrict both the main logic's syntax and semantics.
A new sublogic, or simply logic, is defined in the SMT-LIB language by 
a \define{logic declaration}; see \href{http://www.smt-lib.org}{www.smt-lib.org} for the current catalog.
Logic declarations have a similar format to theory declarations,
although most of their attributes are informal.\endnote{
\label{informal-logic-attribute}
The reason for informal attributes is similar to that for theory declarations.
}

Attributes with the following predefined keywords are 
\define{predefined attributes}, with prescribed usage and semantics 
in logic declarations:
\begin{center}
\attr{theories}\qquad
\attr{language}\qquad
\attr{extensions}\qquad
\attr{notes}\qquad
\attr{values} .
\end{center}
Additionally, 
as with theories, a logic declaration can contain any number of user-defined attributes.
\bigskip

\cLogics
\bigskip

A logic declaration \expr{(logic $L$ $\alpha_1\ \cdots\ \alpha_n$)}
defines a logic with name $L$ and attributes $\alpha_1, \ldots, \alpha_n$.

\begin{constraint}[Logic Declarations]
The only legal logic declarations in the SMT-LIB language are those 
that satisfy the following restrictions:

\begin{enumerate}
\item
They include exactly one occurrence of the \attr{theories} and 
the \attr{language} attribute
(and any number of occurrences of other attributes).

\item
The value \expr{($T_1\ \cdots\ T_n$)} of the \attr{theories} attribute lists
names of theory schemas that have a declaration in SMT-LIB.

\item
If two theory declarations among $T_1, \ldots, T_n$ declare 
the same sort symbol, they give it the same arity.
\end{enumerate}
\end{constraint}


When the value of the \attr{theories} attribute is \expr{($T_1\ \cdots\ T_n$)},
with $n > 0$,
the logic refers to a combination $\T$ of specific instances of 
the theory declaration schemas $T_1, \ldots, T_n$.
The exact combination mechanism that yields $\T$ is defined formally in 
Section~\ref{sec:logics}.
The effect of this attribute is to declare that 
the logic's sort and function symbols consist of those of 
the combined theory $\T$,
and that
the logic's semantics is restricted to the models of $\T$,
as specified in more detail in Section~\ref{sec:logics}.

The \attr{language} attribute describes in free text the logic's
\emph{language}, a specific class of SMT-LIB formulas.
This information is useful for tailoring SMT solvers 
to the specific sublanguage of formulas used in an input script.\endnote{
\label{why-text-language}
The attribute is text-valued because it is mostly for documentation purposes
for the benefit of benchmark users.
A natural language description of the logic's language seems therefore
adequate for this purpose.
Of course, it is also possible to specify the language
at least partially in some formal fashion in this attribute,
for instance by using BNF rules.
}
The formulas in the logic's language are built over (a subset of) 
the signature of the associated theory $\T$, as specified in this attribute.
In the context of a command script the language of a logic 
is implicitly expanded by \ter{let} constructs in formulas as well as 
user-defined (but not user-declared) sort and function symbols.
In other words, a formula $\varphi$ used in a script is considered to belong 
to a certain logic's language
iff
the formula obtained from $\varphi$ by replacing all let variables and 
all defined sort and function symbols by their respective definitions
is in the language.

The optional \attr{extensions} attribute is meant 
to document any notational conventions or syntactic sugar allowed in
the concrete syntax of formulas in this logic.\endnote{
\label{why-extensions}
This is useful because in common practice, the syntax of 
a logic is often extended for convenience with syntactic sugar.
}

The \attr{values} attribute has the same use as in theory declarations
but it refers to the specific theories and sorts of the logic.
It is meant to complement the \attr{values} attributes specified in
the theory declarations referred to in the \attr{theories} attribute.

The textual \attr{notes} attribute serves the same purpose as in theory declarations. 


%-------------------------------------------------------------------------------
\subsection{Examples}
%-------------------------------------------------------------------------------

Defining theories model-theoretically, as opposed to axiomatically 
as in more traditional approaches, confers great expressive power 
to the SMT-LIB underlying logic in spite of its restriction 
to a first-order syntax.
Several established logics, from propositional all the way to higher-order logic, 
can be defined as SMT-LIB sublogics given a suitable theory.
We provide a small sample below, for illustrative purposes.
Again, see \href{http://www.smt-lib.org}{www.smt-lib.org} for the list 
of the actual logics defined in the SMT-LIB standard. 



%-------------------------------------------------------------------------------
\subsubsection*{Propositional logic}
%-------------------------------------------------------------------------------

Propositional logic can be readily defined by an SMT-LIB logic declaration.
The logic's theory is the instance of the \ter{Core} theory declaration
whose signature adds infinitely-many function symbols of rank \ter{Bool}
(playing the role of propositional variables).
The language consists of all binder-free formulas over the expanded signature.
Extending the language with let binders
allows a faithful encoding of binary decision diagrams (BDDs) as formulas,
thanks to the \ter{ite} operator of \ter{Core}.

%-------------------------------------------------------------------------------
\subsubsection*{Quantified Boolean logic}
%-------------------------------------------------------------------------------

The logic of quantified Boolean formulas (QBFs) can be defined as well.
The theory is again an instance of \ter{Core}
but this time with no additional symbols at all.
The language consists of (closed) quantified formulas
all of whose variables are of sort \ter{Bool}.

%-------------------------------------------------------------------------------
\subsubsection*{Linear integer arithmetic}
%-------------------------------------------------------------------------------

Linear integer arithmetic can be defined as an SMT-LIB logic.
This logic is indeed part of the official SMT-LIB catalog of logics
and is called \ter{QF\_LIA} there.
Its theory is an extension of the theory of integers and the Booleans 
with uninterpreted constant symbols.
That is,
it is the instance of the theory declaration \ter{Ints} 
from Figure~\ref{fig:Integers}
whose signature adds to the symbols of \ter{Ints}
infinitely many \emph{free constants},
new function symbols of rank \ter{Int} or of rank \ter{Bool}.

The language of the logic is made of
closed quantifier-free formulas (over the theory's signature)
containing only \emph{linear atoms}, that is, 
atomic formulas with no occurrences of the function symbol \verb|*|.
Extensions of the basic language include 
expressions of the form \expr{(* $n$ $t$)} and \expr{(* $t$ $n$)}, 
for some numeral $n$, 
both of which abbreviate the term \expr{(+ $t\ \cdots\ t$)} 
with $n$ occurrences of $t$ (or 0 if $n$ is 0).
Also included are terms with negative integer coefficients, that is,
expressions of the form \expr{(* (- $n$) $t$)} or \expr{(* $t$ (- $n$))} 
for some numeral $n$,
both of which abbreviate the expression \expr{(- (* $n$ $t$))}.



\begin{figure}%[t]
\small
\cCommands
\caption{SMT-LIB Commands.}
\label{fig:commands}
\end{figure}


%-------------------------------------------------------------------------------
\section{Scripts}  \label{sec:scripts}
%-------------------------------------------------------------------------------

Scripts are sequences of \define{commands}.  
In line with the LISP-like syntax, all commands look like 
LISP-function applications, with a command name applied to zero or more arguments.
To facilitate processing, each command takes a constant number of arguments,
although some of these arguments can be (parenthesis-delimited) lists 
of variable length.
The full list of commands is provided in Figure~\ref{fig:commands}.

The intended use of scripts is to communicate with an SMT-solver 
in a \emph{read-eval-print loop}: until a termination condition occurs, 
the solver reads the next command, acts on it, outputs a response, and repeats.
Possible responses vary from a single symbol to a list of attributes, 
to complex expressions like proofs.


\begin{figure}
\small
\cCommandOptions
\caption{Command options.}
\label{fig:command-options}
\end{figure}

The command \ter{set-option} takes as an argument expressions 
of the syntactic category \nter{option}, which have the same form 
as attributes with values.
Options with the predefined keywords listed in Figure~\ref{fig:command-options} 
have a prescribed usage and semantics.
Additional, solver-specific options are also allowed.


\begin{figure}
\small
\cInfoFlags
\caption{Info flags.}
\label{fig:info-flags}
\end{figure}

The command \ter{get-info} takes as argument 
expressions of the syntactic category \nter{info\_flag}
which are flags with the same form as keywords.
The predefined flags listed in Figure~\ref{fig:info-flags} have 
a prescribed usage and semantics.
Additional, solver-specific flags are also allowed.
Examples of the latter might be, for instance, flags such as
\attr{time} and \attr{memory}, referring to used resources, or  
\attr{decisions}, \attr{conflicts}, and \attr{restarts},
referring to typical statistics for current SMT solvers. 

For more on error behavior, the meanings of the various options and info names,
and the semantics of the various commands, 
see Chapter~\ref{chap:operational-semantics}.
We highlight a few salient points here and provide a couple of examples.


\paragraph{Assertion stack.} 
Compliant solvers respond to various commands mostly by performing operations 
on a data structure we call the \define{assertion stack}.  
This is a single stack whose elements, called \define{levels},
are \emph{sets} of \define{assertions}. 
Assertions include logical formulas (that is, terms of sort \ter{Bool}), 
\emph{as well as} declarations and definitions of sort and function symbols.
Assertions are added by specific commands.
By default, an assertion belongs to the most recent level
at the time the corresponding command was executed.
The stack starts with a \define{first assertion level} 
that cannot be removed.
Further levels can be introduced by a \ter{push} command and 
removed by a corresponding \ter{pop} command.
Popping a level from the assertion stack has the effect of undoing 
all assertions in it, including symbol declarations and definitions.
An input option, \attr{global-declarations}, allows the user to make 
all symbol declarations and definitions \emph{global} to the assertion stack.
In other words, when that option is enabled, declarations and definitions become
permanent, as opposed to being added to the assertion stack.
Popping a stack level then has only the effect of removing asserted formulas 
(those in that level).
Global declarations and definitions can be removed only by a \ter{reset} command.

\paragraph{Declared/defined symbols.}
Sort and function symbols introduced with a declaration or a definition
cannot have a name that begins with a dot (\ter{.}), as such names 
are reserved for solvers' use, or with \ter{@}, as such symbols are reserved 
for solver-defined \emph{abstract values}.

%-------------------------------------------------------------------------------
\subsection{Command responses}
%-------------------------------------------------------------------------------

\begin{figure}
\small

\cResponsesI
\bigskip

\cResponsesII

\caption{Command responses.}
\label{fig:command-responses}
\end{figure}

The possible responses that a solver can produce in response to commands are
shown in Figure~\ref{fig:command-responses}.
Every response must be an instance of \nter{general\_response} which specifies
generic response possibilities as well as command-specific responses
for certain commands (specified by \nter{specific\_success\_response}).  In
addition, with the \attr{print-success} option set to \ter{true}, a solver
returns \ter{success} after a successful command.

Regular output, including error messages, is printed 
on the \define{regular output channel}.
Diagnostic output, including warnings and progress information, 
is printed on the \define{diagnostic output channel}.  
These may be set using \ter{set-option} and the corresponding attributes: 
respectively, \attr{regular-output-channel} and \attr{diagnostic-output-channel}. 
%
The values of these attributes should be (double-quote delimited) 
file names in the format specified by the POSIX standard.\footnote{% 
This is the usual format adopted by all Unix-based operating systems,
with \ter{/} used as a separator for (sub)directories, etc.
}
The string literals \ter{"stdout"} and \ter{"stderr"} are reserved 
to refer specially to the corresponding standard process channels 
(as opposed to disk files with that name).

\paragraph{Specific Responses.}
Specific responses are defined, in Figure~\ref{fig:command-responses},
for the following commands:
\bigskip

{\small
\begin{tabular}{lll}
 \nter{check\_sat\_response} & for & \ter{check-sat} and \ter{check-sat-assuming} \\
 \nter{echo\_response} & for & \ter{echo}, \\
 \nter{get\_assertions\_response} & for & \ter{get-assertions}, \\
 \nter{get\_assignment\_response} & for & \ter{get-assignment}, \\
 \nter{get\_info\_response} & for & \ter{get-info}, \\
 \nter{get\_model\_response} & for & \ter{get-model}, \\
 \nter{get\_option\_response} & for & \ter{get-option}, \\
 \nter{get\_proof\_response} & for & \ter{get-proof}, \\
 \nter{get\_unsat\_assump\_response} & for & \ter{get-unsat-assumptions}, \\
 \nter{get\_unsat\_core\_response} & for & \ter{get-unsat-core}, \\
 \nter{get\_value\_response} & for & \ter{get-value}.
\end{tabular}
}
\bigskip

\noindent See Chapter~\ref{chap:operational-semantics} for more details.


%-------------------------------------------------------------------------------
\subsection{Example scripts}
%-------------------------------------------------------------------------------

\begin{figure}
\footnotesize
\begin{minipage}[t]{.5\linewidth}
\begin{verbatim}
(set-option :print-success true)
; success

(set-info :smt-lib-version 2.7)
; success

(set-logic QF_LIA)
; success

(declare-const w Int)
; success

(declare-const x Int)
; success

(declare-const y Int)
; success

(declare-const z Int)
; success

(assert (> x y))
; success

(assert (> y z))
; success
\end{verbatim}
\end{minipage}
%
\begin{minipage}[t]{.5\linewidth}
\begin{verbatim}
(push 1)

(assert (> z x))

(check-sat)
; unsat

(get-info :all-statistics) 
; (:time 0.01 :memory 0.2)

(pop 1)

(push 1)

(check-sat)
; sat

(exit)
\end{verbatim}
\end{minipage}
\medskip

\caption{\label{fig:eg1}Example script (over two columns), with expected solver responses in comments.}
\end{figure}


\begin{figure}
\footnotesize
\begin{minipage}[t]{.45\linewidth}
\begin{verbatim}
(set-info :smt-lib-version 2.7)
...
(set-option :produce-models true)

(declare-const x Int)
(declare-const y Int)
(declare-fun f (Int) Int)

(assert (= (f x) (f y)))
(assert (not (= x y)))

(check-sat)
; sat

(get-value (x y))
; ((x 0)
;  (y 1)
; )

(declare-const a (Array Int (List Int)))
\end{verbatim}
\end{minipage}
%
\begin{minipage}[t]{.5\linewidth}
\begin{verbatim}
...

(check-sat)
; sat

(get-value (a))
; ( (a (as @array1 (Array Int (List Int))))
; )

(get-value ((select @array1 2)))
; (((select (as @array1 (Array Int (List Int))) 2) 
;   (as @list0 (List Int))
;  )
; )

(get-value ((first @list0) (rest @list0)))
; (((first (as @list0 (List Int))) 1)
;  ((rest (as @list0 (List Int))) (as nil (List Int)))
; )
\end{verbatim}
\end{minipage}
\medskip

\caption{\label{fig:eg2}
Another example script (excerpt), with expected solver responses in comments.
}
\end{figure}

We demonstrate some allowed behavior of a hypothetical solver in response
to an example script.  Each command is followed by example legal
output from the solver in a comment, if there is any.  The script in
Figure~\ref{fig:eg1} makes two background assertions and then
conducts two independent queries.  The \ter{get-info} command requests
information on the search using the \attr{all-statistics} flag.\footnote{%
Since the output of \ter{(get-info :all-statistics)} is solver-specific,
the response reported in the script is for illustration purposes only.
}
The script in Figure~\ref{fig:eg2} uses
the \ter{get-value} command to get information about a particular
model of the formula that the solver has reported satisfiable.


%-------------------------------------------------------------------------------
\subsection{SMT-LIB Benchmarks} \label{sec:benchmarks}
%-------------------------------------------------------------------------------
Starting with Version 2.0 of the SMT-LIB language, 
there is no explicit syntactic category of benchmarks.  
Instead, meta-level information about a script used as a benchmark is included 
in the script via the \ter{set-info} command.  

Benchmarks in the official SMT-LIB repository at \href{http://www.smt-lib.org}{www.smt-lib.org}
must satisfy additional requirements on the meta-level information they contain
and the order in which it appears. 
Specifically, every benchmark must use \ter{set-info} to set
the attributes below as follows: 
%
\begin{itemize}
\item
\attr{smt-lib-version}, \attr{source}, \attr{license}, and \attr{category} must be set exactly once,
\item
\attr{status} must be set as many times as needed so that each occurrence 
of the command \ter{check-sat-assuming} or \ter{check-sat} 
in the benchmark is preceded (not necessarily immediately)
by a corresponding \attr{status} info.\footnote{%
The same call to \ter{set-info} can be used to provide the status 
for more than one call to \ter{check-sat-assuming} or \ter{check-sat},
if that status is the same.
}
\end{itemize}
%
Moreover, the set \ter{set-info} call for attribute \attr{smt-lib-version} must be the very first command in the benchmark.
\medskip
